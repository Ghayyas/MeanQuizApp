/** @module common */ /** for typedoc */
/// <reference path='../../typings/angularjs/angular.d.ts' />
var isDefined = angular.isDefined, isFunction = angular.isFunction, isNumber = angular.isNumber, isString = angular.isString, isObject = angular.isObject, isArray = angular.isArray, forEach = angular.forEach, extend = angular.extend, copy = angular.copy, noop = angular.noop, toJson = angular.toJson, fromJson = angular.fromJson, equals = angular.equals, identity = angular.identity;
exports.isDefined = isDefined;
exports.isFunction = isFunction;
exports.isNumber = isNumber;
exports.isString = isString;
exports.isObject = isObject;
exports.isArray = isArray;
exports.forEach = forEach;
exports.extend = extend;
exports.copy = copy;
exports.noop = noop;
exports.toJson = toJson;
exports.fromJson = fromJson;
exports.equals = equals;
exports.identity = identity;
exports.abstractKey = 'abstract';
// Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function
function curry(fn) {
    var initial_args = [].slice.apply(arguments, [1]);
    var func_args_length = fn.length;
    function curried(args) {
        if (args.length >= func_args_length)
            return fn.apply(null, args);
        return function () {
            return curried(args.concat([].slice.apply(arguments)));
        };
    }
    return curried(initial_args);
}
exports.curry = curry;
/**
 * Given a varargs list of functions, returns a function that is composes the argument functions, right-to-left
 * given: f(x), g(x), h(x)
 * let composed = compose(f,g,h)
 * then, composed is: f(g(h(x)))
 */
function compose() {
    var args = arguments;
    var start = args.length - 1;
    return function () {
        var i = start, result = args[start].apply(this, arguments);
        while (i--)
            result = args[i].call(this, result);
        return result;
    };
}
exports.compose = compose;
/**
 * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right
 * given: f(x), g(x), h(x)
 * let piped = pipe(f,g,h);
 * then, piped is: h(g(f(x)))
 */
function pipe() {
    var funcs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        funcs[_i - 0] = arguments[_i];
    }
    return compose.apply(null, [].slice.call(arguments).reverse());
}
exports.pipe = pipe;
/**
 * Given a property name, returns a function that returns that property from an object
 * let obj = { foo: 1, name: "blarg" };
 * let getName = prop("name");
 * getName(obj) === "blarg"
 */
exports.prop = function (name) { return function (obj) { return obj && obj[name]; }; };
/**
 * Given a property name and a value, returns a function that returns a boolean based on whether
 * the passed object has a property that matches the value
 * let obj = { foo: 1, name: "blarg" };
 * let getName = propEq("name", "blarg");
 * getName(obj) === true
 */
exports.propEq = curry(function (name, val, obj) { return obj && obj[name] === val; });
/**
 * Given a dotted property name, returns a function that returns a nested property from an object, or undefined
 * let obj = { id: 1, nestedObj: { foo: 1, name: "blarg" }, };
 * let getName = prop("nestedObj.name");
 * getName(obj) === "blarg"
 * let propNotFound = prop("this.property.doesnt.exist");
 * propNotFound(obj) === undefined
 */
exports.parse = function (name) { return pipe.apply(null, name.split(".").map(exports.prop)); };
/**
 * Given a function that returns a truthy or falsey value, returns a
 * function that returns the opposite (falsey or truthy) value given the same inputs
 */
exports.not = function (fn) { return function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i - 0] = arguments[_i];
    }
    return !fn.apply(null, args);
}; };
/**
 * Given two functions that return truthy or falsey values, returns a function that returns truthy
 * if both functions return truthy for the given arguments
 */
function and(fn1, fn2) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        return fn1.apply(null, args) && fn2.apply(null, args);
    };
}
exports.and = and;
/**
 * Given two functions that return truthy or falsey values, returns a function that returns truthy
 * if at least one of the functions returns truthy for the given arguments
 */
function or(fn1, fn2) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        return fn1.apply(null, args) || fn2.apply(null, args);
    };
}
exports.or = or;
/** Given a class, returns a Predicate function that returns true if the object is of that class */
exports.is = function (ctor) { return function (obj) { return (obj != null && obj.constructor === ctor || obj instanceof ctor); }; };
/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */
exports.eq = function (val) { return function (other) { return val === other; }; };
/** Given a value, returns a function which returns the value */
exports.val = function (v) { return function () { return v; }; };
function invoke(fnName, args) {
    return function (obj) { return obj[fnName].apply(obj, args); };
}
exports.invoke = invoke;
function pattern(struct) {
    return function (val) {
        for (var i = 0; i < struct.length; i++) {
            if (struct[i][0](val))
                return struct[i][1](val);
        }
    };
}
exports.pattern = pattern;
/**
 * protoypal inheritance helper.
 * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it
 */
exports.inherit = function (parent, extra) { return extend(new (extend(function () { }, { prototype: parent }))(), extra); };
/**
 * Given an arguments object, converts the arguments at index idx and above to an array.
 * This is similar to es6 rest parameters.
 *
 * Optionally, the argument at index idx may itself already be an array.
 *
 * For example,
 * given either:
 *        arguments = [ obj, "foo", "bar" ]
 * or:
 *        arguments = [ obj, ["foo", "bar"] ]
 * then:
 *        restArgs(arguments, 1) == ["foo", "bar"]
 *
 * This allows functions like pick() to be implemented such that it allows either a bunch
 * of string arguments (like es6 rest parameters), or a single array of strings:
 *
 * given:
 *        var obj = { foo: 1, bar: 2, baz: 3 };
 * then:
 *        pick(obj, "foo", "bar");   // returns { foo: 1, bar: 2 }
 *        pick(obj, ["foo", "bar"]); // returns { foo: 1, bar: 2 }
 */
var restArgs = function (args, idx) {
    if (idx === void 0) { idx = 0; }
    return Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(args, idx));
};
/** Given an array, returns true if the object is found in the array, (using indexOf) */
var inArray = function (array, obj) { return array.indexOf(obj) !== -1; };
/** Given an array, an an item, if the item is found in the array, it removes it (in-place).  The same array is returned */
exports.removeFrom = function (array) { return function (obj) {
    var idx = array.indexOf(obj);
    if (idx >= 0)
        array.splice(idx, 1);
    return array;
}; };
/**
 * Applies a set of defaults to an options object.  The options object is filtered
 * to only those properties of the objects in the defaultsList.
 * Earlier objects in the defaultsList take precedence when applying defaults.
 */
function defaults(opts) {
    if (opts === void 0) { opts = {}; }
    var defaultsList = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        defaultsList[_i - 1] = arguments[_i];
    }
    var defaults = merge.apply(null, [{}].concat(defaultsList));
    return extend({}, defaults, pick(opts || {}, Object.keys(defaults)));
}
exports.defaults = defaults;
/**
 * Merges properties from the list of objects to the destination object.
 * If a property already exists in the destination object, then it is not overwritten.
 */
function merge(dst) {
    var objs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        objs[_i - 1] = arguments[_i];
    }
    forEach(objs, function (obj) {
        forEach(obj, function (value, key) {
            if (!dst.hasOwnProperty(key))
                dst[key] = value;
        });
    });
    return dst;
}
exports.merge = merge;
/** Reduce function that merges each element of the list into a single object, using angular.extend */
exports.mergeR = function (memo, item) { return extend(memo, item); };
/**
 * Finds the common ancestor path between two states.
 *
 * @param {Object} first The first state.
 * @param {Object} second The second state.
 * @return {Array} Returns an array of state names in descending order, not including the root.
 */
function ancestors(first, second) {
    var path = [];
    for (var n in first.path) {
        if (first.path[n] !== second.path[n])
            break;
        path.push(first.path[n]);
    }
    return path;
}
exports.ancestors = ancestors;
/**
 * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.
 *
 * @param {Object} a The first object.
 * @param {Object} b The second object.
 * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,
 *                     it defaults to the list of keys in `a`.
 * @return {Boolean} Returns `true` if the keys match, otherwise `false`.
 */
function equalForKeys(a, b, keys) {
    if (keys === void 0) { keys = Object.keys(a); }
    for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        if (a[k] != b[k])
            return false; // Not '===', values aren't necessarily normalized
    }
    return true;
}
exports.equalForKeys = equalForKeys;
function pickOmitImpl(predicate, obj) {
    var objCopy = {}, keys = restArgs(arguments, 2);
    for (var key in obj) {
        if (predicate(keys, key))
            objCopy[key] = obj[key];
    }
    return objCopy;
}
function pick(obj) { return pickOmitImpl.apply(null, [inArray].concat(restArgs(arguments))); }
exports.pick = pick;
function omit(obj) { return pickOmitImpl.apply(null, [exports.not(inArray)].concat(restArgs(arguments))); }
exports.omit = omit;
function pluck(collection, propName) {
    return map(collection, exports.prop(propName));
}
exports.pluck = pluck;
function filter(collection, callback) {
    var arr = isArray(collection), result = arr ? [] : {};
    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };
    forEach(collection, function (item, i) {
        if (callback(item, i))
            accept(item, i);
    });
    return result;
}
exports.filter = filter;
function find(collection, callback) {
    var result;
    forEach(collection, function (item, i) {
        if (result)
            return;
        if (callback(item, i))
            result = item;
    });
    return result;
}
exports.find = find;
function map(collection, callback) {
    var result = isArray(collection) ? [] : {};
    forEach(collection, function (item, i) { return result[i] = callback(item, i); });
    return result;
}
exports.map = map;
/** Given an object, return its enumerable property values */
exports.values = function (obj) { return Object.keys(obj).map(function (key) { return obj[key]; }); };
/** Reduce function that returns true if all of the values are truthy. */
exports.allTrueR = function (memo, elem) { return memo && elem; };
/** Reduce function that returns true if any of the values are truthy. */
exports.anyTrueR = function (memo, elem) { return memo || elem; };
/** Reduce function that pushes an object to an array, then returns the array */
exports.pushR = function (arr, obj) { arr.push(obj); return arr; };
/** Reduce function which un-nests a single level of arrays */
exports.unnestR = function (memo, elem) { return memo.concat(elem); };
/** Reduce function which recursively un-nests all arrays */
exports.flattenR = function (memo, elem) { return isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : exports.pushR(memo, elem); };
/** Return a new array with a single level of arrays unnested. */
exports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };
/** Return a completely flattened version of an array. */
exports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };
/**
 * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.
 */
function assertPredicate(fn, errMsg) {
    if (errMsg === void 0) { errMsg = "assert failure"; }
    return function (obj) {
        if (!fn(obj))
            throw new Error(errMsg);
        return true;
    };
}
exports.assertPredicate = assertPredicate;
/** Like _.pairs: Given an object, returns an array of key/value pairs */
exports.pairs = function (object) { return Object.keys(object).map(function (key) { return [key, object[key]]; }); };
/**
 * Given two or more parallel arrays, returns an array of tuples where
 * each tuple is composed of [ a[i], b[i], ... z[i] ]
 *
 * let foo = [ 0, 2, 4, 6 ];
 * let bar = [ 1, 3, 5, 7 ];
 * let baz = [ 10, 30, 50, 70 ];
 * tuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]
 * tuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]
 *
 */
function arrayTuples() {
    var arrayArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        arrayArgs[_i - 0] = arguments[_i];
    }
    if (arrayArgs.length === 0)
        return [];
    var length = arrayArgs.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53 − 1 aka Number.MAX_SAFE_INTEGER
    return Array.apply(null, Array(length)).map(function (ignored, idx) { return arrayArgs.map(function (arr) { return arr[idx]; }).reduce(exports.pushR, []); });
}
exports.arrayTuples = arrayTuples;
/**
 * Reduce function which builds an object from an array of [key, value] pairs.
 * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.
 *
 * Each keyValueTuple should be an array with values [ key: string, value: any ]
 *
 * Given:
 * var pairs = [ ["fookey", "fooval"], ["barkey","barval"] ]
 * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})
 * // or simply: pairs.reduce(applyPairs, {})
 * Then:
 * true === angular.equals(pairsToObj, { fookey: "fooval", barkey: "barval" })
 */
function applyPairs(memo, keyValTuple) {
    var key, value;
    if (isArray(keyValTuple))
        key = keyValTuple[0], value = keyValTuple[1];
    if (!isString(key))
        throw new Error("invalid parameters to applyPairs");
    memo[key] = value;
    return memo;
}
exports.applyPairs = applyPairs;
// Checks if a value is injectable
function isInjectable(val) {
    if (isArray(val) && val.length) {
        var head = val.slice(0, -1), tail_1 = val.slice(-1);
        if (head.filter(exports.not(isString)).length || tail_1.filter(exports.not(isFunction)).length)
            return false;
    }
    return isFunction(val);
}
exports.isInjectable = isInjectable;
exports.isNull = function (o) { return o === null; };
exports.isPromise = and(isObject, pipe(exports.prop('then'), isFunction));
function fnToString(fn) {
    var _fn = pattern([
        [isArray, function (arr) { return arr.slice(-1)[0]; }],
        [exports.val(true), identity]
    ])(fn);
    return _fn && _fn.toString() || "undefined";
}
exports.fnToString = fnToString;
function maxLength(max, str) {
    if (str.length <= max)
        return str;
    return str.substr(0, max - 3) + "...";
}
exports.maxLength = maxLength;
function padString(length, str) {
    while (str.length < length)
        str += " ";
    return str;
}
exports.padString = padString;
function tail(collection) {
    return collection.length && collection[collection.length - 1] || undefined;
}
exports.tail = tail;
/**
 * @ngdoc overview
 * @name ui.router.util
 *
 * @description
 * # ui.router.util sub-module
 *
 * This module is a dependency of other sub-modules. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 *
 */
angular.module('ui.router.util', ['ng', 'ui.router.init']);
/**
 * @ngdoc overview
 * @name ui.router.router
 *
 * @requires ui.router.util
 *
 * @description
 * # ui.router.router sub-module
 *
 * This module is a dependency of other sub-modules. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 */
angular.module('ui.router.router', ['ui.router.util']);
/**
 * @ngdoc overview
 * @name ui.router.state
 *
 * @requires ui.router.router
 * @requires ui.router.util
 *
 * @description
 * # ui.router.state sub-module
 *
 * This module is a dependency of the main ui.router module. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 *
 */
angular.module('ui.router.state', ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);
/**
 * @ngdoc overview
 * @name ui.router
 *
 * @requires ui.router.state
 *
 * @description
 * # ui.router
 *
 * ## The main module for ui.router
 * There are several sub-modules included with the ui.router module, however only this module is needed
 * as a dependency within your angular app. The other modules are for organization purposes.
 *
 * The modules are:
 * * ui.router - the main "umbrella" module
 * * ui.router.router -
 *
 * *You'll need to include **only** this module as the dependency within your angular app.*
 *
 * <pre>
 * <!doctype html>
 * <html ng-app="myApp">
 * <head>
 *   <script src="js/angular.js"></script>
 *   <!-- Include the ui-router script -->
 *   <script src="js/angular-ui-router.min.js"></script>
 *   <script>
 *     // ...and add 'ui.router' as a dependency
 *     var myApp = angular.module('myApp', ['ui.router']);
 *   </script>
 * </head>
 * <body>
 * </body>
 * </html>
 * </pre>
 */
angular.module('ui.router', ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);
angular.module('ui.router.compat', ['ui.router']);
