/** @module transition */ /** for typedoc */
var common_1 = require("../common/common");
var module_1 = require("./module");
var successErrorOptions = {
    async: false,
    rejectIfSuperseded: false
};
/**
 * This class returns applicable TransitionHooks for a specific Transition instance.
 *
 * Hooks (IEventHook) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.
 * myTransition.onEnter(...).  The HookBuilder finds matching IEventHooks (where the match criteria is
 * determined by the type of hook)
 *
 * The HookBuilder also converts IEventHooks objects to TransitionHook objects, which are used to run a Transition.
 *
 * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder
 * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private
 * in the Transition class, so we must also provide the Transition's _treeChanges)
 *
 */
var HookBuilder = (function () {
    function HookBuilder($transitions, transition, baseHookOptions) {
        var _this = this;
        this.$transitions = $transitions;
        this.transition = transition;
        this.baseHookOptions = baseHookOptions;
        // TODO: These get* methods are returning different cardinalities of hooks
        // onBefore/onStart/onFinish/onSuccess/onError returns an array of hooks
        // onExit/onRetain/onEnter returns an array of arrays of hooks
        this.getOnBeforeHooks = function () { return _this._buildTransitionHooks("onBefore", {}, { async: false }); };
        this.getOnStartHooks = function () { return _this._buildTransitionHooks("onStart"); };
        this.getOnExitHooks = function () { return _this._buildNodeHooks("onExit", _this.treeChanges.exiting.reverse(), function (node) { return _this._toFrom({ from: node.state }); }); };
        this.getOnRetainHooks = function () { return _this._buildNodeHooks("onRetain", _this.treeChanges.retained, function (node) { return _this._toFrom(); }); };
        this.getOnEnterHooks = function () { return _this._buildNodeHooks("onEnter", _this.treeChanges.entering, function (node) { return _this._toFrom({ to: node.state }); }); };
        this.getOnFinishHooks = function () { return _this._buildTransitionHooks("onFinish", { $treeChanges$: _this.treeChanges }); };
        this.getOnSuccessHooks = function () { return _this._buildTransitionHooks("onSuccess", {}, { async: false, rejectIfSuperseded: false }); };
        this.getOnErrorHooks = function () { return _this._buildTransitionHooks("onError", {}, { async: false, rejectIfSuperseded: false }); };
        this.treeChanges = transition.treeChanges();
        this.toState = common_1.tail(this.treeChanges.to).state;
        this.fromState = common_1.tail(this.treeChanges.from).state;
        this.transitionOptions = transition.options();
    }
    HookBuilder.prototype.asyncHooks = function () {
        var onStartHooks = this.getOnStartHooks();
        var onExitHooks = this.getOnExitHooks();
        var onRetainHooks = this.getOnRetainHooks();
        var onEnterHooks = this.getOnEnterHooks();
        var onFinishHooks = this.getOnFinishHooks();
        return common_1.flatten([onStartHooks, onExitHooks, onRetainHooks, onEnterHooks, onFinishHooks]).filter(common_1.identity);
    };
    HookBuilder.prototype._toFrom = function (toFromOverride) {
        return common_1.extend({ to: this.toState, from: this.fromState }, toFromOverride);
    };
    /**
     * Returns an array of newly built TransitionHook objects.
     *
     * Builds a TransitionHook which cares about the entire Transition, for instance, onActivate
     * Finds all registered IEventHooks which matched the hookType and toFrom criteria.
     * A TransitionHook is then built from each IEventHook with the context, locals, and options provided.
     */
    HookBuilder.prototype._buildTransitionHooks = function (hookType, locals, options) {
        var _this = this;
        if (locals === void 0) { locals = {}; }
        if (options === void 0) { options = {}; }
        var context = this.treeChanges.to, node = common_1.tail(context);
        options.traceData = { hookType: hookType, context: context };
        var transitionHook = function (eventHook) { return _this.buildHook(node, eventHook.callback, locals, options); };
        return this._matchingHooks(hookType, this._toFrom()).map(transitionHook);
    };
    /**
     * Returns an 2 dimensional array of newly built TransitionHook objects.
     * Each inner array contains the hooks for a node in the Path.
     *
     * For each Node in the Path:
     * Builds the toFrom criteria
     * Finds all registered IEventHooks which matched the hookType and toFrom criteria.
     * A TransitionHook is then built from each IEventHook with the context, locals, and options provided.
     */
    HookBuilder.prototype._buildNodeHooks = function (hookType, path, toFromFn, locals, options) {
        var _this = this;
        if (locals === void 0) { locals = {}; }
        if (options === void 0) { options = {}; }
        var hooksForNode = function (node) {
            var toFrom = toFromFn(node);
            options.traceData = { hookType: hookType, context: node };
            locals.$state$ = node.state;
            var transitionHook = function (eventHook) { return _this.buildHook(node, eventHook.callback, locals, options); };
            return _this._matchingHooks(hookType, toFrom).map(transitionHook);
        };
        return path.map(hooksForNode);
    };
    /** Given a node and a callback function, builds a TransitionHook */
    HookBuilder.prototype.buildHook = function (node, fn, locals, options) {
        if (options === void 0) { options = {}; }
        var _options = common_1.extend({}, this.baseHookOptions, options);
        return new module_1.TransitionHook(fn, common_1.extend({}, locals), node.resolveContext, _options);
    };
    /**
     * returns an array of the IEventHooks from:
     * - The Transition object instance hook registry
     * - The TransitionService ($transitions) global hook registry
     * which matched:
     * - the eventType
     * - the matchCriteria to state
     * - the matchCriteria from state
     */
    HookBuilder.prototype._matchingHooks = function (hookName, matchCriteria) {
        var matchFilter = function (hook) { return hook.matches(matchCriteria.to, matchCriteria.from); };
        var prioritySort = function (l, r) { return r.priority - l.priority; };
        return [this.transition, this.$transitions] // Instance and Global hook registries
            .map(function (reg) { return reg.getHooks(hookName); }) // Get named hooks from registries
            .filter(common_1.assertPredicate(common_1.isArray, "broken event named: " + hookName)) // Sanity check
            .reduce(common_1.unnestR) // Un-nest IEventHook[][] to IEventHook[] array
            .filter(matchFilter) // Only those satisfying matchCriteria
            .sort(prioritySort); // Order them by .priority field
    };
    return HookBuilder;
})();
exports.HookBuilder = HookBuilder;
