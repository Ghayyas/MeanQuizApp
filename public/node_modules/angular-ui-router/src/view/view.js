/** @module view */ /** for typedoc */
"use strict";
/// <reference path='../../typings/angularjs/angular.d.ts' />
var common_1 = require("../common/common");
var module_1 = require("../common/module");
/**
 * Given a raw view name from a views: config, returns a normalized target viewName and contextAnchor
 */
function normalizeUiViewTarget(rawViewName) {
    if (rawViewName === void 0) { rawViewName = ""; }
    // TODO: Validate incoming view name with a regexp to allow:
    // ex: "view.name@foo.bar" , "^.^.view.name" , "view.name@^.^" , "" ,
    // "@" , "$default@^" , "!$default.$default" , "!foo.bar"
    var viewAtContext = rawViewName.split("@");
    var uiViewName = viewAtContext[0] || "$default"; // default to unnamed view
    var uiViewContextAnchor = common_1.isString(viewAtContext[1]) ? viewAtContext[1] : "^"; // default to parent context
    // Handle relative view-name sugar syntax.
    // Matches rawViewName "^.^.^.foo.bar" into array: ["^.^.^.foo.bar", "^.^.^", "foo.bar"],
    var relativeViewNameSugar = /^(\^(?:\.\^)*)\.(.*$)/.exec(uiViewName);
    if (relativeViewNameSugar) {
        // Clobbers existing contextAnchor (rawViewName validation will fix this)
        uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to "^.^.^"
        uiViewName = relativeViewNameSugar[2]; // set view-name to "foo.bar"
    }
    if (uiViewName.charAt(0) === '!') {
        uiViewName = uiViewName.substr(1);
        uiViewContextAnchor = ""; // target absolutely from root
    }
    return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };
}
/**
 * Represents the union of a template and (optional) controller.
 *
 * @param {Object} config The view's configuration
 *
 * @returns {Object} New `ViewConfig` object
 */
var ViewConfig = (function () {
    function ViewConfig(stateViewConfig) {
        // viewName is something like "$default" or "foo.bar" or "$default.foo.bar.$default"
        // contextAnchor is something like "fully.qualified.context" or "^" (parent) or  "^.^.^" (parent.parent.parent)
        var _a = normalizeUiViewTarget(stateViewConfig.rawViewName), uiViewName = _a.uiViewName, uiViewContextAnchor = _a.uiViewContextAnchor;
        // handle parent relative targeting "^.^.^"
        var relativeMatch = /^(\^(?:\.\^)*)$/;
        if (relativeMatch.exec(uiViewContextAnchor)) {
            var anchor = uiViewContextAnchor.split(".").reduce((function (anchor, x) { return anchor.parent; }), stateViewConfig.context);
            uiViewContextAnchor = anchor.name;
        }
        common_1.extend(this, common_1.pick(stateViewConfig, "viewDeclarationObj", "params", "context", "locals"), { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor });
        this.controllerAs = stateViewConfig.viewDeclarationObj.controllerAs;
    }
    /**
     * Checks a view configuration to ensure that it specifies a template.
     *
     * @return {boolean} Returns `true` if the configuration contains a valid template, otherwise `false`.
     */
    ViewConfig.prototype.hasTemplate = function () {
        var viewDef = this.viewDeclarationObj;
        return !!(viewDef.template || viewDef.templateUrl || viewDef.templateProvider);
    };
    ViewConfig.prototype.getTemplate = function ($factory, injector) {
        return $factory.fromConfig(this.viewDeclarationObj, this.params, injector.invokeLater.bind(injector));
    };
    /**
     * Gets the controller for a view configuration.
     *
     *
     * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.
     */
    ViewConfig.prototype.getController = function (injector) {
        //* @param {Object} locals A context object from transition.context() to invoke a function in the correct context
        var provider = this.viewDeclarationObj.controllerProvider;
        return common_1.isInjectable(provider) ? injector.invokeLater(provider, {}) : this.viewDeclarationObj.controller;
    };
    return ViewConfig;
})();
exports.ViewConfig = ViewConfig;
/**
 * @ngdoc object
 * @name ui.router.state.$view
 *
 * @requires ui.router.util.$templateFactory
 * @requires $rootScope
 *
 * @description
 *
 */
$View.$inject = ['$rootScope', '$templateFactory', '$q', '$timeout'];
function $View($rootScope, $templateFactory, $q, $timeout) {
    var uiViews = [];
    var viewConfigs = [];
    var match = function (obj1) {
        var keys = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            keys[_i - 1] = arguments[_i];
        }
        return function (obj2) { return keys.reduce((function (memo, key) { return memo && obj1[key] === obj2[key]; }), true); };
    };
    this.rootContext = function (context) {
        return context ? this._rootContext = context : this._rootContext;
    };
    /**
     * @ngdoc function
     * @name ui.router.state.$view#load
     * @methodOf ui.router.state.$view
     *
     * @description
     * Uses `$templateFactory` to load a template from a configuration object into a named view.
     *
     * @param {string} name The fully-qualified name of the view to load the template into
     * @param {Object} options The options used to load the template:
     * @param {boolean} options.notify Indicates whether a `$viewContentLoading` event should be
     *    this call.
     * @params {*} options.* Accepts the full list of parameters and options accepted by
     *    `$templateFactory.fromConfig()`, including `params` and `locals`.
     * @return {Promise.<string>} Returns a promise that resolves to the value of the template loaded.
     */
    this.load = function load(viewConfig, injector) {
        if (!viewConfig.hasTemplate())
            throw new Error("No template configuration specified for '" + viewConfig.uiViewName + "@" + viewConfig.uiViewContextAnchor + "'");
        var promises = {
            template: $q.when(viewConfig.getTemplate($templateFactory, injector)),
            controller: $q.when(viewConfig.getController(injector))
        };
        return $q.all(promises).then(function (results) {
            module_1.trace.traceViewServiceEvent("Loaded", viewConfig);
            return common_1.extend(viewConfig, results);
        });
    };
    /**
     * Resets a view to its initial state.
     *
     * @param {String} name The fully-qualified name of the view to reset.
     * @return {Boolean} Returns `true` if the view exists, otherwise `false`.
     */
    this.reset = function reset(viewConfig) {
        module_1.trace.traceViewServiceEvent("<- Removing", viewConfig);
        viewConfigs.filter(match(viewConfig, "uiViewName", "context")).forEach(common_1.removeFrom(viewConfigs));
    };
    this.registerStateViewConfig = function (viewConfig) {
        module_1.trace.traceViewServiceEvent("-> Registering", viewConfig);
        viewConfigs.push(viewConfig);
    };
    this.sync = function () {
        var uiViewsByFqn = uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});
        /**
         * Given a ui-view and a ViewConfig, determines if they "match".
         *
         * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in
         * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.
         *
         * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or
         * can be a segmented ui-view path, describing a portion of a ui-view fqn.
         *
         * If the ViewConfig's target ui-view name is a simple name (no dots), then a ui-view matches if:
         * - the ui-view's name matches the ViewConfig's target name
         * - the ui-view's context matches the ViewConfig's anchor
         *
         * If the ViewConfig's target ui-view name is a segmented name (with dots), then a ui-view matches if:
         * - There exists a parent ui-view where:
         *    - the parent ui-view's name matches the first segment (index 0) of the ViewConfig's target name
         *    - the parent ui-view's context matches the ViewConfig's anchor
         * - And the remaining segments (index 1..n) of the ViewConfig's target name match the tail of the ui-view's fqn
         *
         * Example:
         *
         * DOM:
         * <div ui-view>                        <!-- created in the root context (name: "") -->
         *   <div ui-view="foo">                <!-- created in the context named: "A"      -->
         *     <div ui-view>                    <!-- created in the context named: "A.B"    -->
         *       <div ui-view="bar">            <!-- created in the context named: "A.B.C"  -->
         *       </div>
         *     </div>
         *   </div>
         * </div>
         *
         * uiViews: [
         *  { fqn: "$default",                  creationContext: { name: "" } },
         *  { fqn: "$default.foo",              creationContext: { name: "A" } },
         *  { fqn: "$default.foo.$default",     creationContext: { name: "A.B" } }
         *  { fqn: "$default.foo.$default.bar", creationContext: { name: "A.B.C" } }
         * ]
         *
         * These four view configs all match the ui-view with the fqn: "$default.foo.$default.bar":
         *
         * - ViewConfig1: { uiViewName: "bar",                       uiViewContextAnchor: "A.B.C" }
         * - ViewConfig2: { uiViewName: "$default.bar",              uiViewContextAnchor: "A.B" }
         * - ViewConfig3: { uiViewName: "foo.$default.bar",          uiViewContextAnchor: "A" }
         * - ViewConfig4: { uiViewName: "$default.foo.$default.bar", uiViewContextAnchor: "" }
         *
         * Using ViewConfig3 as an example, it matches the ui-view with fqn "$default.foo.$default.bar" because:
         * - The ViewConfig's segmented target name is: [ "foo", "$default", "bar" ]
         * - There exists a parent ui-view (which has fqn: "$default.foo") where:
         *    - the parent ui-view's name "foo" matches the first segment "foo" of the ViewConfig's target name
         *    - the parent ui-view's context "A" matches the ViewConfig's anchor context "A"
         * - And the remaining segments [ "$default", "bar" ].join("."_ of the ViewConfig's target name match
         *   the tail of the ui-view's fqn "default.bar"
         */
        var matches = common_1.curry(function (uiView, viewConfig) {
            // Split names apart from both viewConfig and uiView into segments
            var vcSegments = viewConfig.uiViewName.split(".");
            var uivSegments = uiView.fqn.split(".");
            // Check if the tails of the segment arrays match. ex, these arrays' tails match:
            // vc: ["foo", "bar"], uiv fqn: ["$default", "foo", "bar"]
            if (!angular.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))
                return false;
            // Now check if the fqn ending at the first segment of the viewConfig matches the context:
            // ["$default", "foo"].join(".") == "$default.foo", does the ui-view $default.foo context match?
            var negOffset = (1 - vcSegments.length) || undefined;
            var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(".");
            var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;
            return viewConfig.uiViewContextAnchor === (uiViewContext && uiViewContext.name);
        });
        // Return the number of dots in the fully qualified name
        function uiViewDepth(uiView) {
            return uiView.fqn.split(".").length;
        }
        // Return the ViewConfig's context's depth in the context tree.
        function viewConfigDepth(config) {
            var context = config.context, count = 0;
            while (++count && context.parent)
                context = context.parent;
            return count;
        }
        // Given a depth function, returns a compare function which can return either ascending or descending order
        var depthCompare = common_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });
        var matchingConfigPair = function (uiView) {
            var matchingConfigs = viewConfigs.filter(matches(uiView));
            if (matchingConfigs.length > 1)
                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending
            return [uiView, matchingConfigs[0]];
        };
        var configureUiView = function (_a) {
            var uiView = _a[0], viewConfig = _a[1];
            // If a parent ui-view is reconfigured, it could destroy child ui-views.
            // Before configuring a child ui-view, make sure it's still in the active uiViews array.
            if (uiViews.indexOf(uiView) !== -1)
                uiView.configUpdated(viewConfig);
        };
        uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair).forEach(configureUiView);
    };
    /**
     * Allows a `ui-view` element to register its canonical name with a callback that allows it to
     * be updated with a template, controller, and local variables.
     *
     * @param {String} name The fully-qualified name of the `ui-view` object being registered.
     * @param {Function} configUpdatedCallback A callback that receives updates to the content & configuration
     *                   of the view.
     * @return {Function} Returns a de-registration function used when the view is destroyed.
     */
    this.registerUiView = function register(uiView) {
        module_1.trace.traceViewServiceUiViewEvent("-> Registering", uiView);
        var fqnMatches = function (uiv) { return uiv.fqn === uiView.fqn; };
        if (uiViews.filter(fqnMatches).length)
            module_1.trace.traceViewServiceUiViewEvent("!!!! duplicate uiView named:", uiView);
        uiViews.push(uiView);
        this.sync();
        return function () {
            var idx = uiViews.indexOf(uiView);
            if (idx <= 0) {
                module_1.trace.traceViewServiceUiViewEvent("Tried removing non-registered uiView", uiView);
                return;
            }
            module_1.trace.traceViewServiceUiViewEvent("<- Deregistering", uiView);
            common_1.removeFrom(uiViews)(uiView);
        };
    };
    /**
     * Returns the list of views currently available on the page, by fully-qualified name.
     *
     * @return {Array} Returns an array of fully-qualified view names.
     */
    this.available = function () { return uiViews.map(common_1.prop("fqn")); };
    /**
     * Returns the list of views on the page containing loaded content.
     *
     * @return {Array} Returns an array of fully-qualified view names.
     */
    this.active = function () { return uiViews.filter(common_1.prop("$config")).map(common_1.prop("name")); };
}
angular.module('ui.router.state').service('$view', $View);
